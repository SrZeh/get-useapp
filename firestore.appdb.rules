rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    function isAuthed() { return request.auth != null; }
    function uid() { return request.auth.uid; }

    function isReturnedReservation(res) {
      return res.status == "returned" || res.status == "closed";
    }

    function hasLowRatingComment() {
      return !(request.resource.data.rating <= 2)
        || (request.resource.data.comment is string && request.resource.data.comment.size() > 0);
    }

    function validItemReviewReservation(itemId, resId) {
      let p = /databases/$(database)/documents/reservations/$(resId);
      if (!exists(p)) return false;
      let resData = get(p).data;
      return resData.itemId == itemId
        && resData.renterUid == uid()
        && isReturnedReservation(resData)
        && resData.itemOwnerUid == request.resource.data.itemOwnerUid;
    }

    function validUserReviewReservation(resId, reviewerRole, targetUid) {
      let p = /databases/$(database)/documents/reservations/$(resId);
      if (!exists(p)) return false;
      let resData = get(p).data;
      return isReturnedReservation(resData)
        && (
          (reviewerRole == "renter"
            && resData.renterUid == uid()
            && resData.itemOwnerUid == targetUid) ||
          (reviewerRole == "owner"
            && resData.itemOwnerUid == uid()
            && resData.renterUid == targetUid)
        );
    }

    // -------- USERS (perfil) --------
    match /users/{u} {
      // leitura pública (para verificar se existe), escrita apenas pelo próprio usuário
      allow read: if true;
      allow create, update: if isAuthed() && uid() == u;
      allow delete: if false;

      match /reviewsReceived/{revId} {
        allow read: if true;
        allow create: if isAuthed()
          && request.resource.data.reviewerUid == uid()
          && request.resource.data.targetUid == u
          && request.resource.data.rating is number
          && request.resource.data.rating >= 1
          && request.resource.data.rating <= 5
          && request.resource.data.reservationId is string
          && revId == request.resource.data.reservationId
          && request.resource.data.reviewerRole in ["owner", "renter"]
          && request.resource.data.targetRole in ["owner", "renter"]
          && (!request.resource.data.keys().hasAny(["comment"]) || (request.resource.data.comment is string && request.resource.data.comment.size() <= 500))
          && hasLowRatingComment()
          && validUserReviewReservation(
            request.resource.data.reservationId,
            request.resource.data.reviewerRole,
            u
          );
        allow update, delete: if false;
      }
    }

    // -------- ITENS (vitrine) + subcoleções --------
    match /items/{itemId} {
      // leitura pública se published == true; dono sempre pode
      allow read: if resource.data.published == true
                  || (isAuthed() && resource.data.ownerUid == uid());

      // criar/editar/apagar: apenas dono autenticado
      allow create: if isAuthed() && request.resource.data.ownerUid == uid();
      allow update, delete: if isAuthed() && resource.data.ownerUid == uid();

      // calendário: somente leitura no cliente; escrita via Functions/Admin
      match /bookedDays/{dayId} {
        allow read: if true;
        allow write: if false;
      }

      // avaliações
      match /reviews/{revId} {
        allow read: if true;
        allow create: if isAuthed()
          && request.resource.data.renterUid == uid()
          && request.resource.data.rating is number
          && request.resource.data.rating >= 1
          && request.resource.data.rating <= 5
          && request.resource.data.reservationId is string
          && request.resource.data.itemOwnerUid is string
          && request.resource.data.itemId == itemId
          && revId == request.resource.data.reservationId
          && (!request.resource.data.keys().hasAny(["comment"]) || (request.resource.data.comment is string && request.resource.data.comment.size() <= 500))
          && hasLowRatingComment()
          && validItemReviewReservation(itemId, request.resource.data.reservationId);
        allow update, delete: if false;
      }
    }

    // -------- RESERVAS + CHAT --------
    match /reservations/{resId} {

      // participante desta reserva?
      function isPartyHere() {
        return isAuthed() && (
          resource.data.itemOwnerUid == uid() ||
          resource.data.renterUid == uid()
        );
      }

      // Para subcoleções: olha o doc pai
      function partyOfReservation() {
        let p = /databases/$(database)/documents/reservations/$(resId);
        return exists(p) && isAuthed() && (
          get(p).data.itemOwnerUid == uid() || get(p).data.renterUid == uid()
        );
      }

      // ---- READ ----
      allow read: if isPartyHere();

      // ---- CREATE ----
      // somente o locatário pode criar sua reserva (status inicial = requested)
      allow create: if isAuthed()
        && request.resource.data.renterUid == uid()
        && request.resource.data.status == "requested";

      // ---- UPDATE ----
      // Somente participantes e com transições válidas
      allow update: if isPartyHere() && validReservationTransition();

      // Transições válidas pelo CLIENTE (pagamento/repasse ficam no servidor)
      function validReservationTransition() {
        let before = resource.data.status;
        let after  = request.resource.data.status;
        let owner  = resource.data.itemOwnerUid;
        let renter = resource.data.renterUid;

        return
          // Dono decide aceitar/recusar
          (before == "requested" && after == "accepted" && uid() == owner) ||
          (before == "requested" && after == "rejected" && uid() == owner) ||
          // Locatário pode cancelar antes do pagamento
          (before == "requested" && after == "canceled" && uid() == renter) ||
          // Cancelar mesmo após aceito (política sua) — sem marcar pago/payout
          ((before == "accepted") && after == "canceled" && (uid() == renter || uid() == owner)) ||
          // Permite updates que NÃO trocam status
          (before == after);
      }

      // ---- DELETE ----
      allow delete: if isPartyHere() &&
        (resource.data.status == "requested" ||
         resource.data.status == "rejected" ||
         resource.data.status == "canceled");

      // ---- CHAT ----
      match /messages/{msgId} {
        allow read: if partyOfReservation();
        allow create: if partyOfReservation()
          && request.resource.data.senderUid == uid()
          && request.resource.data.text is string
          && request.resource.data.text.size() > 0
          && request.resource.data.text.size() <= 2000;
        allow update, delete: if false;
      }
    }
  }
}
