rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    function isAuthed() { return request.auth != null; }
    function uid() { return request.auth.uid; }

    function isReturnedReservation(res) {
      return res.status == "returned" || res.status == "closed";
    }

    function hasLowRatingComment() {
      return !(request.resource.data.rating <= 2)
        || (request.resource.data.comment is string && request.resource.data.comment.size() > 0);
    }

    function validItemReviewReservation(itemId, resId) {
      let p = /databases/$(database)/documents/reservations/$(resId);
      if (!exists(p)) return false;
      let resData = get(p).data;
      return resData.itemId == itemId
        && resData.renterUid == uid()
        && isReturnedReservation(resData)
        && resData.itemOwnerUid == request.resource.data.itemOwnerUid;
    }

    function validUserReviewReservation(resId, reviewerRole, targetUid) {
      let p = /databases/$(database)/documents/reservations/$(resId);
      if (!exists(p)) return false;
      let resData = get(p).data;
      return isReturnedReservation(resData)
        && (
          (reviewerRole == "renter"
            && resData.renterUid == uid()
            && resData.itemOwnerUid == targetUid) ||
          (reviewerRole == "owner"
            && resData.itemOwnerUid == uid()
            && resData.renterUid == targetUid)
        );
    }

    // -------- USERS (perfil) --------
    match /users/{u} {
      // leitura pública (para verificar se existe), escrita apenas pelo próprio usuário
      allow read: if true;
      allow create, update: if isAuthed() && uid() == u;
      allow delete: if false;

      match /reviewsReceived/{revId} {
        allow read: if true;
        allow create: if isAuthed()
          && request.resource.data.reviewerUid == uid()
          && request.resource.data.targetUid == u
          && request.resource.data.rating is number
          && request.resource.data.rating >= 1
          && request.resource.data.rating <= 5
          && request.resource.data.reservationId is string
          && revId == request.resource.data.reservationId
          && request.resource.data.reviewerRole in ["owner", "renter"]
          && request.resource.data.targetRole in ["owner", "renter"]
          && (!request.resource.data.keys().hasAny(["comment"]) || (request.resource.data.comment is string && request.resource.data.comment.size() <= 500))
          && hasLowRatingComment()
          && validUserReviewReservation(
            request.resource.data.reservationId,
            request.resource.data.reviewerRole,
            u
          );
        allow update, delete: if false;
      }
    }

    // -------- ITENS (vitrine) + subcoleções --------
    match /items/{itemId} {
      // leitura pública se published == true; dono sempre pode
      allow read: if resource.data.published == true
                  || (isAuthed() && resource.data.ownerUid == uid());

      // criar/editar/apagar: apenas dono autenticado
      allow create: if isAuthed() && request.resource.data.ownerUid == uid();
      
      // Update: 
      // - Dono pode atualizar tudo
      // - Qualquer usuário autenticado pode atualizar apenas offeredItems e updatedAt de pedidos de ajuda
      allow update: if isAuthed() && (
        // Dono pode atualizar tudo
        resource.data.ownerUid == uid() ||
        // Qualquer usuário pode adicionar ao array offeredItems de pedidos de ajuda
        // Verificamos apenas que é um pedido de ajuda (itemType == "request")
        // Quando usamos arrayUnion, o Firestore pode não incluir todos os campos no request.resource.data
        // então verificamos apenas o resource.data (documento atual)
        (resource.data.itemType == "request")
      );
      
      allow delete: if isAuthed() && resource.data.ownerUid == uid();

      // calendário: somente leitura no cliente; escrita via Functions/Admin
      match /bookedDays/{dayId} {
        allow read: if true;
        allow write: if false;
      }

      // avaliações
      match /reviews/{revId} {
        allow read: if true;
        allow create: if isAuthed()
          && request.resource.data.renterUid == uid()
          && request.resource.data.rating is number
          && request.resource.data.rating >= 1
          && request.resource.data.rating <= 5
          && request.resource.data.reservationId is string
          && request.resource.data.itemOwnerUid is string
          && request.resource.data.itemId == itemId
          && revId == request.resource.data.reservationId
          && (!request.resource.data.keys().hasAny(["comment"]) || (request.resource.data.comment is string && request.resource.data.comment.size() <= 500))
          && hasLowRatingComment()
          && validItemReviewReservation(itemId, request.resource.data.reservationId);
        allow update, delete: if false;
      }
    }

    // -------- RESERVAS + CHAT --------
    match /reservations/{resId} {

      // participante desta reserva?
      function isPartyHere() {
        return isAuthed() && (
          resource.data.itemOwnerUid == uid() ||
          resource.data.renterUid == uid()
        );
      }

      // Para subcoleções: olha o doc pai
      function partyOfReservation() {
        let p = /databases/$(database)/documents/reservations/$(resId);
        return exists(p) && isAuthed() && (
          get(p).data.itemOwnerUid == uid() || get(p).data.renterUid == uid()
        );
      }

      // ---- READ ----
      allow read: if isPartyHere();

      // ---- CREATE ----
      // somente o locatário pode criar sua reserva (status inicial = requested)
      allow create: if isAuthed()
        && request.resource.data.renterUid == uid()
        && request.resource.data.status == "requested";

      // ---- UPDATE ----
      // Somente participantes e com transições válidas
      allow update: if isPartyHere() && validReservationTransition();

      // Transições válidas pelo CLIENTE (pagamento/repasse ficam no servidor)
      function validReservationTransition() {
        let before = resource.data.status;
        let after  = request.resource.data.status;
        let owner  = resource.data.itemOwnerUid;
        let renter = resource.data.renterUid;

        return
          // Dono decide aceitar/recusar
          (before == "requested" && after == "accepted" && uid() == owner) ||
          (before == "requested" && after == "rejected" && uid() == owner) ||
          // Locatário pode cancelar antes do pagamento
          (before == "requested" && after == "canceled" && uid() == renter) ||
          // Cancelar mesmo após aceito (política sua) — sem marcar pago/payout
          ((before == "accepted") && after == "canceled" && (uid() == renter || uid() == owner)) ||
          // Fechar reserva (ocultar da lista) - qualquer participante pode fechar antes de paid_out
          (before != "paid_out" && after == "closed" && (uid() == renter || uid() == owner)) ||
          // Permite updates que NÃO trocam status
          (before == after);
      }

      // ---- DELETE ----
      allow delete: if isPartyHere() &&
        (resource.data.status == "requested" ||
         resource.data.status == "rejected" ||
         resource.data.status == "canceled");

      // ---- CHAT ----
      match /messages/{msgId} {
        allow read: if partyOfReservation();
        allow create: if partyOfReservation()
          && request.resource.data.senderUid == uid()
          && request.resource.data.text is string
          && request.resource.data.text.size() > 0
          && request.resource.data.text.size() <= 2000;
        // Permitir deletar apenas as próprias mensagens
        // Verifica diretamente se senderUid existe e é igual ao uid
        allow delete: if isAuthed() 
          && resource.data.senderUid is string
          && resource.data.senderUid == uid();
        allow update: if false;
      }
    }

    // -------- THREADS (conversas diretas entre usuários) --------
    match /threads/{threadId} {
      // Verifica se o usuário é participante do thread (para leitura/atualização)
      // participants pode ser um array ou um map (objeto)
      function isThreadParticipant() {
        return isAuthed() && resource.data != null && (
          (resource.data.participants is list && uid() in resource.data.participants) ||
          (resource.data.participants is map && uid() in resource.data.participants)
        );
      }

      // Para subcoleções: verifica se é participante do thread pai
      function participantOfThread() {
        let p = /databases/$(database)/documents/threads/$(threadId);
        if (!exists(p)) return false;
        let threadData = get(p).data;
        return isAuthed() && (
          (threadData.participants is list && uid() in threadData.participants) ||
          (threadData.participants is map && uid() in threadData.participants)
        );
      }

      // Criar thread: usuário autenticado pode criar, mas deve estar nos participants
      // Verifica apenas request.resource.data (não resource.data, que não existe na criação)
      // Verifica se participants é array e contém o uid do usuário autenticado
      allow create: if isAuthed()
        && request.resource.data.participants is list
        && request.resource.data.participants.size() == 2
        && uid() in request.resource.data.participants;

      // Ler thread: permite ler threads que não existem (para verificar antes de criar)
      // OU se o documento existe e o usuário é participante
      // Simplificado: qualquer usuário autenticado pode ler (para verificar existência)
      // A validação de participação será feita na aplicação
      allow read: if isAuthed();

      // Atualizar thread: apenas participantes (ex: atualizar lastMsgAt)
      allow update: if isThreadParticipant()
        && (!request.resource.data.diff(resource.data).affectedKeys().hasAny(['participants']));

      // Deletar: apenas participantes podem deletar threads
      allow delete: if isThreadParticipant();

      // Mensagens do thread
      match /messages/{msgId} {
        allow read: if participantOfThread();
        allow create: if participantOfThread()
          && request.resource.data.fromUid == uid()
          && request.resource.data.text is string
          && request.resource.data.text.size() > 0
          && request.resource.data.text.size() <= 2000;
        allow update, delete: if false;
      }

      // Participantes do thread (unreadCount, lastReadAt)
      match /participants/{participantUid} {
        // Função auxiliar: verifica se o usuário é participante do thread pai
        // Verifica tanto no documento existente quanto no request (para transações)
        function isParticipantOfParentThread() {
          let p = /databases/$(database)/documents/threads/$(threadId);
          // Se o thread existe, verifica nos dados existentes
          if (exists(p)) {
            let threadData = get(p).data;
            return isAuthed() && (
              (threadData.participants is list && uid() in threadData.participants) ||
              (threadData.participants is map && uid() in threadData.participants)
            );
          }
          // Se o thread não existe ainda (criação em transação), permite se o usuário é o próprio participante
          // A validação de que o usuário está nos participants do thread é feita na regra de create do thread
          return isAuthed() && uid() == participantUid;
        }
        
        // Para ler: verifica se é participante do thread pai
        allow read: if isParticipantOfParentThread();
        // Para criar: usuário deve ser o próprio participante
        // Permite criar mesmo se o thread pai não existe ainda (criação em transação)
        // A validação completa de que o usuário está nos participants do thread é feita na regra de create do thread
        allow create: if isAuthed() && uid() == participantUid;
        // Para atualizar: usuário deve ser o próprio participante E ser participante do thread pai
        allow update: if isAuthed() && uid() == participantUid && isParticipantOfParentThread();
        allow delete: if false;
      }
    }

  }
}
